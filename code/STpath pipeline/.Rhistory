zero_prop <- rowSums(filt_matrix == 0)/ncol(filt_matrix)
pdf(file.path(figure_dir, "zero_proportions_all.pdf"), width = 8, height = 5)
ggplot() +
geom_histogram(aes(x=zero_prop), binwidth = 0.01) +
geom_vline(xintercept = 0.9, col = "red") +
geom_vline(xintercept = 0.8, col = "blue") +
labs(title = "All Samples") +
annotate("text", x= 0.3, y=9000, col = "red",
label= paste0(sum(zero_prop < 0.9), " genes are expressed in more than 10% spots.")) +
annotate("text", x = 0.3, y=8500, col = "blue",
label = paste0(sum(zero_prop < 0.8), " genes are expressed in more than 20% spots."))
dev.off()
filtered_obj <- CreateSeuratObject(counts = filt_matrix, project = "all", min.cells = 0.1*ncol(filt_matrix))
# Update metadata for filtered object
filtered_obj@meta.data <- cbind(select(filtered_obj@meta.data, -c("orig.ident")),
select(merged_st_obj@meta.data, -c("nCount_RNA", "nFeature_RNA"))[rownames(merged_st_obj_filt@meta.data), ])
filtered_obj[["RNA"]] <- split(filtered_obj[["RNA"]], f = filtered_obj$sid)
merged_st_obj_filt <- filtered_obj
filtered_obj
# Save the Seurat object
save(merged_st_obj_filt, file=file.path(processed_data_dir, "merged_st_obj_filt_zeros_all.RData"))
# Generate QC plots for filtered data
create_qc_plots(merged_st_obj_filt, "filt_zeros_all")
# library(Matrix)
# library(gridExtra)
# library(cowplot)
library(Seurat)
theme_set(theme_cowplot())
library(ggplot2)
theme_set(theme_cowplot())
library(cowplot)
theme_set(theme_cowplot())
options(future.globals.maxSize = 1e9)
# Define directory paths
raw_data_dir = "../../../st2image_data/He_et_al_2020/data/"
processed_data_dir = "../../data/He_2020/"
figure_dir = "../../figure/He_2020/"
# Load symbol mapping data
load(file.path(processed_data_dir, "id_symbol_mapping.RData"))
# Load Seurat object
load(file.path(processed_data_dir, "merged_st_obj_filt_zeros_all.RData"))
# Normalization function
normalize_data <- function(obj) {
obj <- SCTransform(obj, return.only.var.genes = F) # SCTransform normalization
obj <- RunPCA(obj, reduction.name = "pca.unintegrated.sct") # PCA
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca.unintegrated.sct") # Find neighbors
obj <- FindClusters(obj, resolution = 0.1, cluster.name = "unintegrated.sct_clusters_0.1") # Find clusters
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.unintegrated.sct", reduction.name = "umap.unintegrated.sct") # Run UMAP
DefaultAssay(obj) <- "RNA" # Switch to RNA assay
obj <- NormalizeData(obj) # Log-normalization
obj <- FindVariableFeatures(obj) # Identify variable features
obj <- ScaleData(obj, assay="RNA", features = rownames(obj)) # Scale data
obj <- RunPCA(obj, reduction.name = "pca.unintegrated.lognorm") # PCA
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca.unintegrated.lognorm") # Find neighbors
obj <- FindClusters(obj, resolution = 0.1, cluster.name = "unintegrated.lognorm_clusters_0.1") # Find clusters
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.unintegrated.lognorm", reduction.name = "umap.unintegrated.lognorm") # Run UMAP
obj
}
# Normalization function
normalize_data <- function(obj) {
obj <- SCTransform(obj, return.only.var.genes = F) # SCTransform normalization
obj <- RunPCA(obj, reduction.name = "pca.unintegrated.sct") # PCA
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca.unintegrated.sct") # Find neighbors
obj <- FindClusters(obj, resolution = 0.1, cluster.name = "unintegrated.sct_clusters_0.1") # Find clusters
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.unintegrated.sct", reduction.name = "umap.unintegrated.sct") # Run UMAP
DefaultAssay(obj) <- "RNA" # Switch to RNA assay
obj <- NormalizeData(obj) # Log-normalization
obj <- FindVariableFeatures(obj, nfeatures = 2000) # Identify variable features
obj <- ScaleData(obj, assay="RNA", features = rownames(obj)) # Scale data
obj <- RunPCA(obj, reduction.name = "pca.unintegrated.lognorm") # PCA
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca.unintegrated.lognorm") # Find neighbors
obj <- FindClusters(obj, resolution = 0.1, cluster.name = "unintegrated.lognorm_clusters_0.1") # Find clusters
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.unintegrated.lognorm", reduction.name = "umap.unintegrated.lognorm") # Run UMAP
obj
}
merged_st_obj <- normalize_data(merged_st_obj) # Normalize data
merged_st_obj_filt <- normalize_data(merged_st_obj_filt) # Normalize data
merged_st_obj_filt
merged_st_obj <- merged_st_obj_filt
save(merged_st_obj, file = file.path(processed_data_dir, "merged_st_obj_normalized_filt_zeros_all.rds")) # Save normalized object
saveRDS(merged_st_obj, file = file.path(processed_data_dir, "merged_st_obj_normalized_filt_zeros_all.rds")) # Save normalized object
# Integrate data
integrated_st_obj <- integrate_data(merged_st_obj)
# Integration function
integrate_data <- function(obj) {
obj <- IntegrateLayers(object = obj, method = CCAIntegration, normalization.method = "LogNormalize", orig.reduction = "pca.unintegrated.lognorm", new.reduction = "integrated.cca.lognorm")
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, normalization.method = "LogNormalize", orig.reduction = "pca.unintegrated.lognorm", new.reduction = "integrated.rpca.lognorm", k.weight = 80)
obj <- IntegrateLayers(object = obj, method = HarmonyIntegration, normalization.method = "LogNormalize", orig.reduction = "pca.unintegrated.lognorm", new.reduction = "integrated.harmony.lognorm", verbose = TRUE)
DefaultAssay(obj) <- "SCT"
obj <- IntegrateLayers(object = obj, method = CCAIntegration, normalization.method = "SCT", orig.reduction = "pca.unintegrated.sct", new.reduction = "integrated.cca.sct")
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, normalization.method = "SCT", orig.reduction = "pca.unintegrated.sct", new.reduction = "integrated.rpca.sct", k.weight = 80)
obj <- IntegrateLayers(object = obj, method = HarmonyIntegration, normalization.method = "SCT", orig.reduction = "pca.unintegrated.sct", new.reduction = "integrated.harmony.sct", verbose = TRUE)
obj
}
# Integrate data
integrated_st_obj <- integrate_data(merged_st_obj)
saveRDS(integrated_st_obj, file = file.path(processed_data_dir, paste0("integrated_st_obj_", suffix, ".rds")))
# Define directory paths
processed_data_dir = "../../data/He_2020/"
cluster_rslt_dir = "../../output/He_2020/clustering/"
# Load Seurat object to be clustered
suffix <- "filt_zeros_all"
merged_st_obj <- readRDS(file.path(processed_data_dir, paste0("merged_st_obj_", suffix, ".rds")))
saveRDS(integrated_st_obj, file = file.path(processed_data_dir, paste0("integrated_st_obj_", suffix, ".rds")))
reductions <- names(integrated_st_obj@reductions)[startsWith(names(integrated_st_obj@reductions), "integrated")]
reductions
reductions[grepl("lognrom", reductions)]
grepl("lognrom", reductions)
reductions[grepl("lognorm", reductions)]
reductions[grepl("sct", reductions)]
# Clustering function
perform_clustering <- function(obj) {
reductions <- names(obj@reductions)[startsWith(names(obj@reductions), "integrated")]
DefaultAssay(obj) <- "RNA"
for (red in reductions[grepl("lognorm", reductions)]) {
obj <- FindNeighbors(obj, reduction = red, dims = 1:30)
obj <- FindClusters(obj, resolution = c(0.3, 0.2, 0.1, 0.05), cluster.name = paste0(red, "_clusters_", c(0.3, 0.2, 0.1, 0.05)))
obj <- RunUMAP(obj, reduction = red, dims = 1:30, reduction.name = paste0("umap.", red))
}
DefaultAssay(obj) <- "SCT"
for (red in reductions[grepl("sct", reductions)]) {
obj <- FindNeighbors(obj, reduction = red, dims = 1:30)
obj <- FindClusters(obj, resolution = c(0.3, 0.2, 0.1, 0.05), cluster.name = paste0(red, "_clusters_", c(0.3, 0.2, 0.1, 0.05)))
obj <- RunUMAP(obj, reduction = red, dims = 1:30, reduction.name = paste0("umap.", red))
}
DefaultAssay(obj) <- "RNA"
obj <- JoinLayers(obj)
DefaultAssay(obj) <- "SCT"
obj <- PrepSCTFindMarkers(obj, assay = "SCT", verbose = TRUE)
obj
}
# Perform clustering
clustered_st_obj <- perform_clustering(integrated_st_obj)
saveRDS(clustered_st_obj, file = file.path(cluster_rslt_dir, paste0("clustered_st_obj_", suffix, ".rds")))
clustered_st_obj
View(clustered_st_obj@meta.data)
# Identify all markers
markers_identified <- identify_DE_markers(clustered_st_obj)
# Identify differentially expressed genes
identify_DE_markers <- function(obj) {
cluster_methods <- sort(colnames(obj@meta.data)[startsWith(colnames(obj@meta.data), "integrated")])
markers_identified <- list()
for (cm in cluster_methods) {
m <- strsplit(cm, "_")[[1]][1]
norm <- strsplit(m, ".", fixed = TRUE)[[1]][3]
DefaultAssay(obj) <- ifelse(norm == "lognorm", "RNA", "SCT")
Idents(obj) <- cm
markers <- FindAllMarkers(obj, verbose = TRUE)
markers_identified[[cm]] <- markers
}
markers_identified
}
# Identify top 10 differentially expressed markers
identify_top10_markers <- function(markers_identified) {
top10_DE_markers <- list()
for (cm in names(markers_identified)) {
markers_cm <- markers_identified[[cm]]
if (nrow(markers_cm) == 0) {
top10_DE_markers[[cm]] <- data.frame()
} else {
top10 <- markers_cm %>%
group_by(cluster) %>%
filter(p_val_adj < 0.001 & avg_log2FC > 0) %>%
slice_max(avg_log2FC, n = 10) %>%
ungroup()
top10$gene_symbol <- plyr::mapvalues(top10$gene, from = id_symbol_mapping$id, to = id_symbol_mapping$symbol)
top10_DE_markers[[cm]] <- top10
}
}
top10_DE_markers
}
# Identify all markers
markers_identified <- identify_DE_markers(clustered_st_obj)
saveRDS(markers_identified, file = file.path(cluster_rslt_dir, paste0("DE_markers_identified_", suffix, ".rds")))
# Extract the top10 markers
top10_DE_markers <- identify_top10_markers(markers_identified)
saveRDS(top10_DE_markers, file = file.path(cluster_rslt_dir, paste0("top10_DE_markers_identified_", suffix, ".rds")))
library(tidyverse)
# Extract the top10 markers
top10_DE_markers <- identify_top10_markers(markers_identified)
saveRDS(top10_DE_markers, file = file.path(cluster_rslt_dir, paste0("top10_DE_markers_identified_", suffix, ".rds")))
library(Seurat)
library(tidyverse)
library(Matrix)
library(ggplot2)
library(cowplot)
theme_set(theme_cowplot())
options(future.globals.maxSize = 1e9)
# Define directory paths
raw_data_dir = "../../../st2image_data/He_et_al_2020/data/"
processed_data_dir = "../../data/He_2020/"
figure_dir = "../../figure/He_2020/"
# Load processed metadata for spots with information, proportions and annotations.
load(file.path(processed_data_dir, "prop_ann_meta.RData"))
# Read ST data metadata
st_meta <- read.csv(file.path(raw_data_dir, "metadata.csv"))
# Get unique IDs for spots in ST data
spots <- unique(prop_ann_meta$X)
# Function to process the count matrix of each sample and create Seurat object
process_sample <- function(sample_meta) {
# Get sample ID
s1 <- paste0(sample_meta$patient, "_", sample_meta$replicate)
print(s1)
# Get the cancer subtype
type1 <- sample_meta$type
# Simplify subtype
type1 <- ifelse(type1 %in% c('Luminal_A', 'Luminal_B'), "ER+",
ifelse(type1 %in% c('HER2_luminal', 'HER2_non_luminal'), "HER2+", type1))
# Read and preprocess count matrix
st_counts_s <- read.csv(file.path(raw_data_dir, sample_meta$count_matrix), sep = "\t") %>%
remove_rownames() %>%
column_to_rownames(var="X") %>%
t() %>%
as("CsparseMatrix") %>%
.[startsWith(rownames(.), "ENSG"),] # Keep only rows starting with "ENSG"
# Select spots that are in ST data and belongs to this sample and subset the corresponding count matrix
spots_s <- spots[startsWith(spots, s1)]
spots_s <- sapply(strsplit(spots_s, "_"), function(x) x[3])
st_counts_s <- st_counts_s[, spots_s]
# Create Seurat object with spots in ST data
CreateSeuratObject(counts = st_counts_s, min.features = 100, project = s1)
}
# Function to create QC plots
create_qc_plots <- function(obj, prefix) {
pdf(file.path(figure_dir, paste0(prefix, "_QC.pdf")), width = 24, height = 8)
features <- c("nFeature_RNA", "nCount_RNA") # Features for QC plots
Idents(obj) <- "sid"
for (feature in features) {
p1 <- VlnPlot(obj, features = feature, ncol = 1, split.by = "subtype", cols = scales::hue_pal()(5)) + # Violin plots split by subtype
VlnPlot(obj, features = feature, ncol = 1, split.by = "lab") # Violin plots split by lab
print(p1)
}
# Scatter plots for QC
p2 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "subtype", split.by = "sid", ncol = 9, cols = scales::hue_pal()(5)) +
FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "lab", split.by = "sid", ncol = 9)
print(p2)
dev.off()
}
# Create a merged Seurat object for all samples ---------------------------
# Process all samples and create Seurat object for each sample
all_st_obj <- lapply(1:nrow(st_meta), function(i) process_sample(st_meta[i,]))
# Merge Seurat objects into one over
merged_st_obj <- merge(x=all_st_obj[[1]],y = c(all_st_obj)[-1],
add.cell.ids = paste0(st_meta$patient, "_", st_meta$replicate))
# Add metadata to merged Seurat object
metadata <- merged_st_obj@meta.data %>%
dplyr::rename(sid = orig.ident) %>%
mutate(X = rownames(.),
pid = sapply(str_split(sid, "_"), `[[`, 1),
rid = sapply(str_split(sid, "_"), `[[`, 2),
subtype = plyr::mapvalues(pid, from = unique(st_meta[,c("type", "patient")])$patient, to = unique(st_meta[,c("type", "patient")])$type),
label = plyr::mapvalues(X, from = unique(prop_ann_meta[,c("X", "label")])$X, to = unique(prop_ann_meta[,c("X", "label")])$label),
lab = ifelse(rid %in% c("C1", "C2", "D1"), "lab_C1_C2_D1", "lab_D2_E1_E2"))
# Assign metadata to Seurat object
merged_st_obj@meta.data <- metadata
# Save the Seurat object
saveRDS(merged_st_obj, file = file.path(processed_data_dir, "merged_st_obj_unfilt.rds")) # Save the Seurat object
# Generate QC plots for unfiltered data
create_qc_plots(merged_st_obj, "unfilt")
# Filter spots ------------------------------------------------------------
# Gene detection filtering (filter out spots with abnormal gene detection)
ggplot() +
geom_density(aes(x=log10(merged_st_obj$nFeature_RNA)))
tmp <- merged_st_obj$nFeature_RNA
mean(tmp>4000)
mean(tmp<500)
# Filter spots that have unique feature counts over 4000 or less than 500
high_det <- WhichCells(merged_st_obj, expression = nFeature_RNA > 4000)
low_det <- WhichCells(merged_st_obj, expression = nFeature_RNA < 500)
filtered_cells <- setdiff(WhichCells(merged_st_obj), c(low_det, high_det))
merged_st_obj_tmp <- subset(merged_st_obj, cells = filtered_cells)
# Number of cells after filtering
cbind(table(Idents(merged_st_obj)), table(Idents(merged_st_obj_tmp)))
# Remove genes that are no longer expressed in any cell
all_st_obj_filt <- list()
for(l1 in Layers(merged_st_obj_tmp)){
s1 = gsub("counts.", "", l1)
print(s1)
filt_matrix <- GetAssayData(merged_st_obj_tmp, "RNA", layer = l1)
filtered_obj <- CreateSeuratObject(counts = filt_matrix, project = s1, min.cells = 3)
filtered_obj$orig.ident <- s1
all_st_obj_filt[[s1]] <- filtered_obj
}
merged_st_obj_filt <- merge(x=all_st_obj_filt[[1]], y = c(all_st_obj_filt)[-1])
# Update metadata for filtered object
merged_st_obj_filt@meta.data <- cbind(select(merged_st_obj_filt@meta.data, -c("orig.ident")),
select(merged_st_obj@meta.data, -c("nCount_RNA", "nFeature_RNA"))[rownames(merged_st_obj_filt@meta.data), ])
# Save the Seurat object
saveRDS(merged_st_obj_filt, file=file.path(processed_data_dir, "merged_st_obj_filt_spots.rds"))
# Generate QC plots for filtered data
create_qc_plots(merged_st_obj_filt, "filt_spots")
# Get the list of genes that are expressed in more than 10% of spots in each sample.
pdf(file.path(figure_dir, "zero_proportions.pdf"), width = 8, height = 5)
high_expr_genes <- list()
low_expr_genes <- list()
for(l1 in Layers(merged_st_obj_tmp)){
s1 = gsub("counts.", "", l1)
print(s1)
filt_matrix <- GetAssayData(merged_st_obj_tmp, "RNA", layer = l1)
zero_prop <- rowSums(filt_matrix == 0)/ncol(filt_matrix)
p <- ggplot() +
geom_histogram(aes(x=zero_prop), binwidth = 0.01) +
geom_vline(xintercept = 0.9, col = "red") +
geom_vline(xintercept = 0.8, col = "blue") +
labs(title = s1) +
annotate("text", x= 0.3, y=2500, col = "red",
label= paste0(sum(zero_prop < 0.9), " genes are expressed in more than 10% spots.")) +
annotate("text", x = 0.3, y=2300, col = "blue",
label = paste0(sum(zero_prop < 0.8), " genes are expressed in more than 20% spots."))
print(p)
high_expr_genes[[l1]] <- rownames(filt_matrix)[zero_prop < 0.9]
low_expr_genes[[l1]] <- rownames(filt_matrix)[zero_prop >= 0.9]
}
dev.off()
# Get intersection of genes that are expressed in more than 10% of spots in each sample.
common_high_expr_genes <- Reduce(intersect, high_expr_genes)
length(common_high_expr_genes)
# Get intersection of genes that are not expressed in more than 90% of spots in each sample.
common_low_expr_genes <- Reduce(intersect, low_expr_genes)
length(common_low_expr_genes)
# Filter genes 1 ----------------------------------------------------------
# 1. Remove genes that are not expressed in more than 90% of spots for each sample.
all_st_obj_filt <- list()
for(l1 in Layers(merged_st_obj_tmp)){
s1 = gsub("counts.", "", l1)
print(s1)
filt_matrix <- GetAssayData(merged_st_obj_tmp, "RNA", layer = l1)
filtered_obj <- CreateSeuratObject(counts = filt_matrix, project = s1, min.cells = 0.1*ncol(filt_matrix))
filtered_obj$orig.ident <- s1
all_st_obj_filt[[s1]] <- filtered_obj
}
merged_st_obj_filt <- merge(x=all_st_obj_filt[[1]], y = c(all_st_obj_filt)[-1])
# Update metadata for filtered object
merged_st_obj_filt@meta.data <- cbind(select(merged_st_obj_filt@meta.data, -c("orig.ident")),
select(merged_st_obj@meta.data, -c("nCount_RNA", "nFeature_RNA"))[rownames(merged_st_obj_filt@meta.data), ])
# Save the Seurat object
saveRDS(merged_st_obj_filt, file=file.path(processed_data_dir, "merged_st_obj_filt_zeros_per_sample.rds"))
# Generate QC plots for filtered data
create_qc_plots(merged_st_obj_filt, "filt_zeros_per_sample")
# Filter genes 2 ----------------------------------------------------------
# 2. Remove genes that are not expressed in more than 90% of spots in at least one sample.
all_st_obj_filt <- list()
for(l1 in Layers(merged_st_obj_tmp)){
s1 = gsub("counts.", "", l1)
print(s1)
filt_matrix <- GetAssayData(merged_st_obj_tmp, "RNA", layer = l1)
filt_matrix <- filt_matrix[common_high_expr_genes,]
filtered_obj <- CreateSeuratObject(counts = filt_matrix, project = s1, min.cells = 0)
filtered_obj$orig.ident <- s1
all_st_obj_filt[[s1]] <- filtered_obj
}
merged_st_obj_filt <- merge(x=all_st_obj_filt[[1]], y = c(all_st_obj_filt)[-1])
# Update metadata for filtered object
merged_st_obj_filt@meta.data <- cbind(select(merged_st_obj_filt@meta.data, -c("orig.ident")),
select(merged_st_obj@meta.data, -c("nCount_RNA", "nFeature_RNA"))[rownames(merged_st_obj_filt@meta.data), ])
# Save the Seurat object
saveRDS(merged_st_obj_filt, file=file.path(processed_data_dir, "merged_st_obj_filt_common_high_expr_genes.rds"))
# Generate QC plots for filtered data
create_qc_plots(merged_st_obj_filt, "filt_common_high_expr_genes")
# Filter genes 3 ----------------------------------------------------------
# 3. Remove genes that are not expressed in more than 90% of all pooled spots
merged_st_obj_tmp <- JoinLayers(merged_st_obj_tmp)
filt_matrix <- GetAssayData(merged_st_obj_tmp, "RNA", layer = "counts")
zero_prop <- rowSums(filt_matrix == 0)/ncol(filt_matrix)
pdf(file.path(figure_dir, "zero_proportions_all.pdf"), width = 8, height = 5)
ggplot() +
geom_histogram(aes(x=zero_prop), binwidth = 0.01) +
geom_vline(xintercept = 0.9, col = "red") +
geom_vline(xintercept = 0.8, col = "blue") +
labs(title = "All Samples") +
annotate("text", x= 0.3, y=9000, col = "red",
label= paste0(sum(zero_prop < 0.9), " genes are expressed in more than 10% spots.")) +
annotate("text", x = 0.3, y=8500, col = "blue",
label = paste0(sum(zero_prop < 0.8), " genes are expressed in more than 20% spots."))
dev.off()
filtered_obj <- CreateSeuratObject(counts = filt_matrix, project = "all", min.cells = 0.1*ncol(filt_matrix))
# Update metadata for filtered object
filtered_obj@meta.data <- cbind(select(filtered_obj@meta.data, -c("orig.ident")),
select(merged_st_obj@meta.data, -c("nCount_RNA", "nFeature_RNA"))[rownames(merged_st_obj_filt@meta.data), ])
filtered_obj[["RNA"]] <- split(filtered_obj[["RNA"]], f = filtered_obj$sid)
merged_st_obj_filt <- filtered_obj
# Save the Seurat object
saveRDS(merged_st_obj_filt, file=file.path(processed_data_dir, "merged_st_obj_filt_zeros_all.rds"))
# Generate QC plots for filtered data
create_qc_plots(merged_st_obj_filt, "filt_zeros_all")
library(Seurat)
library(ggplot2)
library(cowplot)
library(tidyverse)
theme_set(theme_cowplot())
options(future.globals.maxSize = 1e9)
# Normalization function
normalize_data <- function(obj) {
obj <- SCTransform(obj, return.only.var.genes = F) # SCTransform normalization
obj <- RunPCA(obj, reduction.name = "pca.unintegrated.sct") # PCA
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca.unintegrated.sct") # Find neighbors
obj <- FindClusters(obj, resolution = 0.1, cluster.name = "unintegrated.sct_clusters_0.1") # Find clusters
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.unintegrated.sct", reduction.name = "umap.unintegrated.sct") # Run UMAP
DefaultAssay(obj) <- "RNA" # Switch to RNA assay
obj <- NormalizeData(obj) # Log-normalization
obj <- FindVariableFeatures(obj, nfeatures = 2000) # Identify variable features
obj <- ScaleData(obj, assay="RNA", features = rownames(obj)) # Scale data
obj <- RunPCA(obj, reduction.name = "pca.unintegrated.lognorm") # PCA
obj <- FindNeighbors(obj, dims = 1:30, reduction = "pca.unintegrated.lognorm") # Find neighbors
obj <- FindClusters(obj, resolution = 0.1, cluster.name = "unintegrated.lognorm_clusters_0.1") # Find clusters
obj <- RunUMAP(obj, dims = 1:30, reduction = "pca.unintegrated.lognorm", reduction.name = "umap.unintegrated.lognorm") # Run UMAP
obj
}
# Integration function
integrate_data <- function(obj) {
obj <- IntegrateLayers(object = obj, method = CCAIntegration, normalization.method = "LogNormalize", orig.reduction = "pca.unintegrated.lognorm", new.reduction = "integrated.cca.lognorm")
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, normalization.method = "LogNormalize", orig.reduction = "pca.unintegrated.lognorm", new.reduction = "integrated.rpca.lognorm", k.weight = 80)
obj <- IntegrateLayers(object = obj, method = HarmonyIntegration, normalization.method = "LogNormalize", orig.reduction = "pca.unintegrated.lognorm", new.reduction = "integrated.harmony.lognorm", verbose = TRUE)
DefaultAssay(obj) <- "SCT"
obj <- IntegrateLayers(object = obj, method = CCAIntegration, normalization.method = "SCT", orig.reduction = "pca.unintegrated.sct", new.reduction = "integrated.cca.sct")
obj <- IntegrateLayers(object = obj, method = RPCAIntegration, normalization.method = "SCT", orig.reduction = "pca.unintegrated.sct", new.reduction = "integrated.rpca.sct", k.weight = 80)
obj <- IntegrateLayers(object = obj, method = HarmonyIntegration, normalization.method = "SCT", orig.reduction = "pca.unintegrated.sct", new.reduction = "integrated.harmony.sct", verbose = TRUE)
obj
}
# Clustering function
perform_clustering <- function(obj) {
reductions <- names(obj@reductions)[startsWith(names(obj@reductions), "integrated")]
DefaultAssay(obj) <- "RNA"
for (red in reductions[grepl("lognorm", reductions)]) {
obj <- FindNeighbors(obj, reduction = red, dims = 1:30)
obj <- FindClusters(obj, resolution = c(0.3, 0.2, 0.1, 0.05), cluster.name = paste0(red, "_clusters_", c(0.3, 0.2, 0.1, 0.05)))
obj <- RunUMAP(obj, reduction = red, dims = 1:30, reduction.name = paste0("umap.", red))
}
DefaultAssay(obj) <- "SCT"
for (red in reductions[grepl("sct", reductions)]) {
obj <- FindNeighbors(obj, reduction = red, dims = 1:30)
obj <- FindClusters(obj, resolution = c(0.3, 0.2, 0.1, 0.05), cluster.name = paste0(red, "_clusters_", c(0.3, 0.2, 0.1, 0.05)))
obj <- RunUMAP(obj, reduction = red, dims = 1:30, reduction.name = paste0("umap.", red))
}
DefaultAssay(obj) <- "RNA"
obj <- JoinLayers(obj)
DefaultAssay(obj) <- "SCT"
obj <- PrepSCTFindMarkers(obj, assay = "SCT", verbose = TRUE)
obj
}
# Clustering function
perform_clustering <- function(obj) {
reductions <- names(obj@reductions)[startsWith(names(obj@reductions), "integrated")]
DefaultAssay(obj) <- "RNA"
for (red in reductions[grepl("lognorm", reductions)]) {
obj <- FindNeighbors(obj, reduction = red, dims = 1:30)
obj <- FindClusters(obj, resolution = c(0.3, 0.2, 0.1, 0.05), cluster.name = paste0(red, "_clusters_", c(0.3, 0.2, 0.1, 0.05)))
obj <- RunUMAP(obj, reduction = red, dims = 1:30, reduction.name = paste0("umap.", red))
}
DefaultAssay(obj) <- "SCT"
for (red in reductions[grepl("sct", reductions)]) {
obj <- FindNeighbors(obj, reduction = red, dims = 1:30)
obj <- FindClusters(obj, resolution = c(0.3, 0.2, 0.1, 0.05), cluster.name = paste0(red, "_clusters_", c(0.3, 0.2, 0.1, 0.05)))
obj <- RunUMAP(obj, reduction = red, dims = 1:30, reduction.name = paste0("umap.", red))
}
DefaultAssay(obj) <- "RNA"
obj <- JoinLayers(obj)
DefaultAssay(obj) <- "SCT"
obj <- PrepSCTFindMarkers(obj, assay = "SCT", verbose = TRUE)
obj
}
# Identify differentially expressed genes
identify_DE_markers <- function(obj) {
cluster_methods <- sort(colnames(obj@meta.data)[startsWith(colnames(obj@meta.data), "integrated")])
markers_identified <- list()
for (cm in cluster_methods) {
m <- strsplit(cm, "_")[[1]][1]
norm <- strsplit(m, ".", fixed = TRUE)[[1]][3]
DefaultAssay(obj) <- ifelse(norm == "lognorm", "RNA", "SCT")
Idents(obj) <- cm
markers <- FindAllMarkers(obj, verbose = TRUE)
markers_identified[[cm]] <- markers
}
markers_identified
}
# Identify top 10 differentially expressed markers
identify_top10_markers <- function(markers_identified) {
top10_DE_markers <- list()
for (cm in names(markers_identified)) {
markers_cm <- markers_identified[[cm]]
if (nrow(markers_cm) == 0) {
top10_DE_markers[[cm]] <- data.frame()
} else {
top10 <- markers_cm %>%
group_by(cluster) %>%
filter(p_val_adj < 0.001 & avg_log2FC > 0) %>%
slice_max(avg_log2FC, n = 10) %>%
ungroup()
top10$gene_symbol <- plyr::mapvalues(top10$gene, from = id_symbol_mapping$id, to = id_symbol_mapping$symbol)
top10_DE_markers[[cm]] <- top10
}
}
top10_DE_markers
}
# Define directory paths
processed_data_dir = "../../data/He_2020/"
cluster_rslt_dir = "../../output/He_2020/clustering/"
# Load Seurat object to be clustered
suffix <- "filt_zeros_all"
merged_st_obj <- readRDS(file.path(processed_data_dir, paste0("merged_st_obj_", suffix, ".rds")))
setwd("~/GitHub/STpath/code/STpath pipeline")
# Load processed metadata for spots with information, proportions and annotations.
load(file.path(processed_data_dir, "prop_ann_meta.RData"))
raw_data_dir = "../../../st2image_data/He_et_al_2020/data/"
processed_data_dir = "../../data/He_2020/"
figure_dir = "../../figure/He_2020/"
# Load processed metadata for spots with information, proportions and annotations.
load(file.path(processed_data_dir, "prop_ann_meta.RData"))
View(prop_ann_meta)
# Read ST data metadata
st_meta <- read.csv(file.path(raw_data_dir, "metadata.csv"))
View(st_meta)
